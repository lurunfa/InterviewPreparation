这是本人在阅读教程和平时问题的随笔记录
==
## java数组复制

在java中有[四种](https://blog.csdn.net/tingzhiyi/article/details/52344845)拷贝数组方式
其中速度最快的是System.arraycopy，因为他是使用C语言已经编译好的本地方法，其次是Object.clone方式，这种需要实现Cloneable接口，并且他们的复制都是属于*浅复制*有浅肯定有深拉 他两二者在复制对象属性的问题下有所[区别](https://www.cnblogs.com/nickhan/p/8569329.html)，如A类持有B类的对象做为成员变量，在复制A类的过程中，如果新A类中的B类对象还是指向原A类对象中B类对象。那么便是浅复制，否则便属于深复制，即新A类中的B类成员变量的内存地址与原A类中的B类对象不一致。
速度差距的原因，
1. 是否是C实现的本地方法,System.clone
2. 在复制过程中是否需要强转，Object.clone
3. 是否需要判断复制时的长度。如Arrays.copy
补充 Arrays.copy也是浅复制。
深复制需要B类也是先Cloneable接口


## 比较器Comparator和Comparable
1. Comparable是内部比较器，指的是一个类自身的不同对象能够比较。因此耦合性较强。一般实现了内部比较器的对象能够保存在一些特定的集合Set中。
2. Comparator是一个外部的比较器，它相当于对于一些没有实现Compareable的类或者实现了内比较器但是不满意时，可以允许用户自己建立比较器对这种类进行比较。Comparator<T> 因此只能和自身类比较。需要用户实现compare方法。

## o(1), o(n), o(logn), o(nlogn)说明
- 表明的是算法的时间复杂度或空间复杂度。表明算法的耗时/耗空间与数据增长量之间的关系，即O(n)表示当数据量增加n倍时，算法的耗时增加n倍。
- O(n)代表数据量增加几倍，算法耗时也增加几倍，我们普通的遍历算法就是这个
- O（n*2）代表数据量增加几倍，算法耗时增加n的2次方倍。我们的冒泡排序就是这种算法，因为对n个数排序，每次都要扫描n*n次。这种比线性O（n）要大
- O（logn）这里的log是以2为底，因此当数据量增加256倍时，则算法耗时增加8倍 2^8 = 256,二分查找就是这种算法，每次遍历删除一半。
- O（nlogn）同理，是n*logn，当数据量增加256倍时，算法耗时增加8*256 = 2048倍，这种算法耗时比线性大但是比O（n^2）小。
- O（1）是最低时间复杂度的，与数据量无关。无论数据增加多少，都可以一次计算就能找到目标（不考虑冲突）

## String.intern
``` java
        String s1 = new String("1");
        s1.intern();
        String s2 = "1";
        System.out.println(s1 == s2);

        //QueueTest1.testBasket();
        String s3 = new String("1")+new String("1");
        //
        s3.intern();
        String s4 = "11";
        System.out.println(s3 == s4 );
```
- 首先先要理解` String s1 = new String("1");`发生了什么，这句话一共产生了两个对象，一个是引用类型的对象存储在堆上的，一个时存储在常量池中的。而s1指向的是堆中的对象。s2是指向常量池中的"1",因此无论s1调用intern与否，这两者的指针是不可能相同的。
- 在下面的s3和s4的比较中，jdk1.6及以前返回false；jdk1.7以后返回true；首先按照上面的理论，s3指向的是堆中的11对象，注意，此时并没有在常量池中产生11对象。因此当s3调用intern方法时，将s3指向的对象放入常量池中，此刻常量池中的11与堆中的11完全一致。当s4赋值时，直接从常量池中取出11，因此导致返回为true。
- 在jdk1.7之前，字符串的常量池放在堆（方法区，perm就是方法区）的perm区域，perm区是一个类静态的区域，主要存储一些加载类的信息，常量池，方法片段等内容，默认大小只有4m。这个区域与堆完全隔离，因此上述调用intern时，在pern区域重新生成了一个新对象11.导致和堆中的内存对象不一致。

