这是本人在阅读教程和平时问题的随笔记录
==
## java数组复制

在java中有[四种](https://blog.csdn.net/tingzhiyi/article/details/52344845)拷贝数组方式
其中速度最快的是System.arraycopy，因为他是使用C语言已经编译好的本地方法，其次是Object.clone方式，这种需要实现Cloneable接口，并且他们的复制都是属于*浅复制*有浅肯定有深拉 他两二者在复制对象属性的问题下有所[区别](https://www.cnblogs.com/nickhan/p/8569329.html)，如A类持有B类的对象做为成员变量，在复制A类的过程中，如果新A类中的B类对象还是指向原A类对象中B类对象。那么便是浅复制，否则便属于深复制，即新A类中的B类成员变量的内存地址与原A类中的B类对象不一致。
速度差距的原因，
1. 是否是C实现的本地方法,System.clone
2. 在复制过程中是否需要强转，Object.clone
3. 是否需要判断复制时的长度。如Arrays.copy
补充 Arrays.copy也是浅复制。
深复制需要B类也是先Cloneable接口


## 比较器Comparator和Comparable
1. Comparable是内部比较器，指的是一个类自身的不同对象能够比较。因此耦合性较强。一般实现了内部比较器的对象能够保存在一些特定的集合Set中。
2. Comparator是一个外部的比较器，它相当于对于一些没有实现Compareable的类或者实现了内比较器但是不满意时，可以允许用户自己建立比较器对这种类进行比较。Comparator<T> 因此只能和自身类比较。需要用户实现compare方法。

## o(1), o(n), o(logn), o(nlogn)说明
- 表明的是算法的时间复杂度或空间复杂度。表明算法的耗时/耗空间与数据增长量之间的关系，即O(n)表示当数据量增加n倍时，算法的耗时增加n倍。
- O(n)代表数据量增加几倍，算法耗时也增加几倍，我们普通的遍历算法就是这个
- O（n*2）代表数据量增加几倍，算法耗时增加n的2次方倍。我们的冒泡排序就是这种算法，因为对n个数排序，每次都要扫描n*n次。这种比线性O（n）要大
- O（logn）这里的log是以2为底，因此当数据量增加256倍时，则算法耗时增加8倍 2^8 = 256,二分查找就是这种算法，每次遍历删除一半。
- O（nlogn）同理，是n*logn，当数据量增加256倍时，算法耗时增加8*256 = 2048倍，这种算法耗时比线性大但是比O（n^2）小。
- O（1）是最低时间复杂度的，与数据量无关。无论数据增加多少，都可以一次计算就能找到目标（不考虑冲突）

